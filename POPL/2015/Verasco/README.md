今天我来分享一下Verasco这个项目，先介绍一些背景知识。

静态分析器有两个主要的特性，一个是静态，它是不知道程序输入的，因为是在编译期进行分析；另外一个是不需要用户进行证明，所以需要工具来自动推导出各种运行时的性质。
它既可以自动验证用户提供的ensure和require是否满足；也可以用来自动验证程序没有未定义行为，也就是这个项目做的事情。

这个项目用到的技术是抽象解释，也就是用一种非标准的语义（这边叫它抽象语义）来执行程序，因为是在编译期分析，需要它终止。这种抽象语义要正确的对程序语义进行估计。可以看这四个图，黑色的箭头是程序实际的执行路径，红色的地方表示程序出错，绿色的框表示抽象语义对程序进行的估计。右下角是错误的估计，产生了假阴性，也就是程序执行的时候会超出估计的范围进入到程序错误的地方，其他三个是正确的估计，左下角的估计比较精确，因为不会产生假阳性。

Verasco就是第一个在Coq中被形式化验证的静态分析器，但是有局限，没有处理递归和动态内存分配。递归在论文中讨论说可以通过k-CFA来处理。

然后来总览一下项目的架构。
这个项目是非常模块化的，上层是由下层参数化。首先他们复用了Compcert的前端，分析器工作在C#minor上（可以理解成没有Type的C语言），用了和Compcert一样的程序语义，这样就能保证静态分析器分析出来的性质能传递到编译出来的汇编码上。

然后是抽象解释器，会分析C#minor的AST，它工作在一个monad上，如果有问题会给出警告。对于循环，会计算出一个post-fixpoint，用了widening和narrowing来加速收敛。它是通过C#minor上的霍尔逻辑来证明了正确性的。

下一层是程序状态抽象层，主要负责指针引用，会检查内存上读取的安全性

最底层是很多可以按需取用的数值模块，处理整数和浮点数的约束条件，非关系型和关系型的约束都可以处理，并且可以把非关系型的约束信息传递给关系型约束。

在程序状态抽象层和数值模块中有一层连接层，用来把数值转化为机器表示，因为整数Z是可以远超int表示范围的，如果有数值溢出、反转之类的未定义行为会在这层处理。

这里有几个例子。第一个例子里 红色处需要数值模块来计算取值范围，绿色处需要程序状态层来确定访问没有越界，最后黄色处可以得到精确的y的范围。第二个例子很经典，在循环里能推导出source+destination=9，然后就能确定数组访问没有越界，并且推导出循环结束时source等于10。

开始讲技术细节，首先是抽象函数alpha和具象函数gamma，对于红色的这些具体状态，抽象函数alpha会把他们映射到一个抽象状态，具象函数gamma会把这个抽象状态映射回一堆具象状态，也就是绿色这个框。

然后对于具象状态上的操作F，可以通过alpha函数来定义它在抽象状态上的对应操作F#。a是抽象状态，通过gamma把它映射到具象状态的集合，然后在具象状态上做F操作，然后再通过alpha映射回抽象状态。然后还可以定义出抽象操作F#的正确性，如果一个具象状态x属于抽象状态a通过gamma映射到的集合里，那么在x上做操作F之后，a上做操作F#，仍然满足这个关系。第二条最精确的性质说的是F#算出来的一定是最小的满足这个性质的抽象状态。根据这个定义，如果有alpha和gamma，是可以直接计算出F#的算法定义的。

但是因为alpha在Coq里没法定义出来，甚至有些情况下alpha可以不存在，所以这个项目没有定义alpha。直接猜了一个F#的定义，然后证明它的正确性。

这样的话就放弃了一些精确性，比如join操作可以不返回最小上界，fixpoint计算可以不要求最小不动点。

这里是程序状态抽象层的一个例子，上面定义了偏序关系，join操作和widening操作。

抽象操作对应了程序的具象操作，这里举个assign的specification的例子：右边是在抽象状态a上进行抽象操作assign x e然后再用gamma映射到具象状态，左边集合里的元素是 取在抽象状态a映射到的具象状态集合的元素具象状态rho，在rho上表达式e能求值成v，然后在rho上将x赋值成v。按照这样就能定义好抽象状态上所有操作的正确性。

对于C#minor来说，它的控制流是复杂的，比如这种情况，在loop里可以break出来，如果用霍尔三元组是很难描述这种情况的。

这个例子里需要把霍尔三元组扩充成四元组，在后条件里增加一个break的情况，这样遇到break之后，会把前条件加到break后条件里，

然后循环结束的时候，循环里面break后条件就是整个循环的正常后条件。

这样就可以定义好抽象解释器了。输入是一个前条件和一个程序，输出是正常后条件和break后条件。正确性分两步来证明：第一步证明解释器的正确性，也就是如果计算能有结果（报错就没有结果了），计算结果确实符合霍尔四元组。第二步是证明霍尔四元组在C#minor语义上的正确性，能确保没有未定义行为。

当然实际的C#minor要更加复杂，是霍尔七元组，因为要处理goto和return。

对于函数调用，这个解释器会直接展开函数定义，因为Coq的停机检查，实现上它们限制了至多展开多少层。

对于不动点计算，我们有kleene定理来保证一个良序的偏序集，对于单增连续函数F，一定可以通过有限步迭代求出最小不动点。

但是大部分都不是良序的，不一定能够收敛。而且就算可以收敛，收敛速度也非常慢。这个例子里一次就+1，完全不够用。

所以就引入了widening的技术，来让迭代快速收敛，可以求出一个post-fixpoint，但是因为大概率不是最小不动点，牺牲了精确性。举个例子，如果第一次算出来的区间是[l1, u1], 第二次算出来[l2, u2]，如果l2比l1小，那左边直接就改成负无穷，右边同理。

为了更精确，还要需要narrowing，因为对于post-fixpoint，再用F进行迭代得到的也是一个post-fixpoint，而且往往精度会更高，对于让精度更低的情况，不做这一步就可以了。

如图所示，红色慢慢爬梯子的就是kleene迭代，虽然可以收敛但是很慢。深蓝色就是widening，可以很快收敛得到一个post-fixpoint，淡蓝色就是narrowing，可以让精度更高。

具体实现的时候，为了通过coq的停机检查，映入了N narrow这个参数，表示在通过widening找到一个post-fixpoint之后至多做这么多次narrowing。

Verasco的数值抽象层支持了五种类型的约束，interval和octagon最常见，用来判断数组越界。congruence可以用来判断访问是否对齐。

octagon处理这样的约束：正负x加减y小于等于某个常数，技术细节上是做成了一个约束矩阵。

如果有x，y，z的非关系型范围约束，可以计算出xyz相互之间的关系型约束。

但是如果全部计算出来，会让约束矩阵过于稠密，

所以只有当增加约束的时候，才去更新矩阵。比如增加了x+y小于等于2，那么就只增加和x，y有关的行列，保持了矩阵的稀疏性。

symbolic equalities主要是为了处理compcert前端编译时候产生的中间变量问题。像这个例子，需要tmp和a的关系。

所以在这个例子里，遇到 0<=a是true，tmp是a＜10，0<=a是false，tmp是0的时候，从if出来后，会自动把tmp和a的关系添加进去，这样先遇到if tmp的时候就可以展开tmp，得到a的信息。

这个静态分析器的终极定理如上所示。vanalysis接收一个prog作为输入，用到了之前的抽象解释器，如果alarm list是空，那么程序不会产生未定义行为。

这里是一些参考资料。
